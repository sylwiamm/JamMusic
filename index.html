<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <title>Jam Music Lab</title>
</head>
<body>
  <div class="container">
    <h1>Mapping the Sound</h1>
    <p class="subtitle">
      Visualizing the Global Reach of Vienna's Jam Music Lab Faculty Through Concerts, Tours, and Collaborations
    </p>
    <div class="legend-container">
        <div class="legend-title">Number <br>of Concerts</div>
        <div class="legend-content">
            <div class="legend-row">
                <div class="legend">
                    <div class="legend-circle"></div>
                    <div class="legend-text">Larger bubbles indicate<br>more concerts</div>
                </div>
            </div>
            <div class="legend-row">
                <div class="heatmap-legend">
                    <div class="heatmap-label">Less</div>
                    <div class="heatmap-box"></div>
                    <div class="heatmap-box"></div>
                    <div class="heatmap-box"></div>
                    <div class="heatmap-box"></div>
                    <div class="heatmap-box"></div>
                    <div class="heatmap-label">More</div>
                </div>
            </div>
        </div>
    </div>
    <div class="calendar-container">
      <div id="calendar"></div>
    </div>
    <svg id="mapSvg"></svg>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
  <script>
    // Resize function to handle window resizing
    function resizeMap() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      // Clear previous content
      d3.select("#mapSvg").html("");

      // Set SVG dimensions
      d3.select("#mapSvg")
        .attr("width", width)
        .attr("height", height);

      drawMap(width, height);
    }

    // Function to create calendar heatmap
    function createCalendarHeatmap(data) {
      // Validate and clean date entries
      const validData = data.filter(d => {
        // Check if date exists and is in valid format (YYYY-MM-DD)
        if (!d.date) return false;

        const datePattern = /^\d{4}-\d{2}-\d{2}$/;
        if (!datePattern.test(d.date)) return false;

        // Check if the date is valid and falls within 2024
        const parsedDate = new Date(d.date);
        return !isNaN(parsedDate) && parsedDate.getFullYear() === 2024;
      });

      // Count events by date
      const dateCount = {};
      validData.forEach(d => {
        if (dateCount[d.date]) {
          dateCount[d.date]++;
        } else {
          dateCount[d.date] = 1;
        }
      });

      // Parameters
      const cellSize = 15;
      const cellMargin = 2;
      const width = 960;
      const height = 150;

      // Date formats
      const formatMonth = d3.timeFormat("%b");
      const formatDate = d3.timeFormat("%Y-%m-%d");

      // Calculate year range
      const year = 2024;
      const startDate = new Date(year, 0, 1);
      const endDate = new Date(year, 11, 31);

      // Calculate day of week offset
      const firstDayOfYear = new Date(year, 0, 1);
      const firstDayOffset = firstDayOfYear.getDay();

      // Color scale - using white with varying opacity for dark theme
      const maxCount = d3.max(Object.values(dateCount)) || 1;
      const colorScale = d3.scaleSequential()
        .domain([0, maxCount])
        .interpolator(d => `rgba(255, 255, 255, ${d/maxCount * 20 + 0.2})`);  // White with opacity

      // Create the SVG element
      const svg = d3.select("#calendar")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .style("position", "relative");  // Override absolute positioning

      // Add tooltip
      const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

      // Days of week labels (vertical)
      const dayLabels = svg.selectAll(".day-label")
        .data(["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"])
        .enter()
        .append("text")
        .attr("class", "day-label")
        .attr("x", 20)
        .attr("y", (d, i) => (i * (cellSize + cellMargin)) + cellSize / 2 + 30)
        .style("text-anchor", "end")
        .text(d => d);

      // Month labels (horizontal)
      const monthLabels = svg.selectAll(".month-label")
        .data(d3.range(0, 12))
        .enter()
        .append("text")
        .attr("class", "month-label")
        .attr("x", d => {
          // Calculate x position for month labels
          const date = new Date(year, d, 1);
          const firstDayOfMonth = date.getDay() || 7; // Convert Sunday from 0 to 7
          const weekOfYear = Math.floor((d3.timeDay.count(d3.timeYear(date), date) + (firstDayOfMonth - 1)) / 7);
          return weekOfYear * (cellSize + cellMargin) + 30;
        })
        .attr("y", 20)
        .style("text-anchor", "start")
        .text(d => formatMonth(new Date(year, d, 1)));

      // Create a group for the day cells
      const dayGroup = svg.append("g")
        .attr("transform", `translate(30, 30)`);

      // Generate an array of all days in the year
      const days = [];
      let currentDate = new Date(startDate);

      while (currentDate <= endDate) {
        days.push(new Date(currentDate));
        currentDate.setDate(currentDate.getDate() + 1);
      }

      // Draw the day cells
      const dayCells = dayGroup.selectAll(".day")
        .data(days)
        .enter()
        .append("rect")
        .attr("class", d => {
          const dateStr = formatDate(d);
          return dateCount[dateStr] ? "day" : "day no-data";
        })
        .attr("width", cellSize)
        .attr("height", cellSize)
        .attr("x", d => {
          // Calculate the week number
          const dayOfYear = d3.timeDay.count(d3.timeYear(d), d);
          const weekNum = Math.floor((dayOfYear + firstDayOffset) / 7);
          return weekNum * (cellSize + cellMargin);
        })
        .attr("y", d => {
          // Get the day of week (0 = Sunday, 1 = Monday, etc.)
          let dayOfWeek = d.getDay() || 7; // Convert Sunday from 0 to 7
          dayOfWeek = dayOfWeek - 1; // Adjust to 0-indexed for Monday first
          if (dayOfWeek < 0) dayOfWeek = 6; // Sunday becomes the last day
          return dayOfWeek * (cellSize + cellMargin);
        })
        .attr("fill", d => {
          const dateStr = formatDate(d);
          return dateCount[dateStr] ? colorScale(dateCount[dateStr]) : "#2a2a2a";
        })
        .attr("rx", 2)
        .attr("ry", 2)
        .on("mouseover", function(event, d) {
          const dateStr = formatDate(d);

          // Find events for this date
          const eventsOnDate = validData.filter(item => item.date === dateStr);

          tooltip.transition()
            .duration(200)
            .style("opacity", 0.9);

          let tooltipContent = `<strong>${d.toDateString()}</strong><br>`;

          if (eventsOnDate.length > 0) {
            tooltipContent += `Events: ${eventsOnDate.length}<br><br>`;
            eventsOnDate.forEach(event => {
              tooltipContent += `${event.full_name} (${event.instrument})<br>`;
              tooltipContent += `${event.city}, ${event.country}<br><br>`;
            });
          } else {
            tooltipContent += "No performances";
          }

          tooltip.html(tooltipContent)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 28) + "px");

          d3.select(this)
            .attr("stroke", "#fff")
            .attr("stroke-width", 1);
        })
        .on("mouseout", function() {
          tooltip.transition()
            .duration(500)
            .style("opacity", 0);

          d3.select(this)
            .attr("stroke", "#3a3a3a")
            .attr("stroke-width", d => {
              const dateStr = formatDate(d);
              return dateCount[dateStr] ? 0 : 1;
            });
        });

      // Display a message if no valid data is found
      if (validData.length === 0) {
        svg.append("text")
          .attr("x", width / 2)
          .attr("y", height / 2)
          .attr("text-anchor", "middle")
          .attr("fill", "#ccc")
          .style("font-size", "14px")
          .text("No performance data for 2024");
      }
    }

    function drawMap(width, height) {
      // Define margins
      const margin = {
        top: 125,
        right: 0,
        bottom: 0,
        left: -50
      };

      // Get SVG element
      const svg = d3.select("#mapSvg");

      // Create a group for the map with margins applied
      const mapGroup = svg.append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

      // Load world map data first
      d3.json("data/world.json")
        .then(function(world) {
          console.log("World data loaded successfully:", world);

          // Generate dot pattern points
          const points = generateDotPattern(width, height, world);

          // Draw the dots
          mapGroup.selectAll(".map-dot")
            .data(points)
            .join("circle")
            .attr("class", "map-dot")
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("r", d => d.avg / 255 * 2) // Adjust the size based on the average value
            .attr("fill", "#636363");

          // Set up the projection for the bubbles
          const projection = d3.geoNaturalEarth1()
            .fitSize([innerWidth, innerHeight], {type: "Sphere"});

          d3.csv("data/events.csv")
            .then(function(csvData) {
              if (!csvData || csvData.length === 0) {
                console.warn("CSV data is empty:", csvData);
                return;
              }

              console.log("CSV data loaded successfully:", csvData);

              createCalendarHeatmap(csvData);

              // Process CSV data
              try {
                // Check if CSV has the expected columns
                const firstRow = csvData[0];
                if (!firstRow.hasOwnProperty('latitude') || !firstRow.hasOwnProperty('longitude') ||
                    !firstRow.hasOwnProperty('city') || !firstRow.hasOwnProperty('country')) {
                  console.error("CSV missing required columns. Expected: latitude, longitude, city, country");
                  console.log("Available columns:", Object.keys(firstRow));

                  // List all available columns
                  const availableColumns = Object.keys(firstRow).join(", ");
                  svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", 80)
                    .attr("text-anchor", "middle")
                    .text(`Available columns: ${availableColumns}`);

                  return;
                }

                const cityData = processCSVData(csvData);
                console.log("Processed city data:", cityData);

                if (cityData.length === 0) {
                  console.log("No valid city data found in CSV.");
                  return;
                }

                console.log(`Displaying ${cityData.length} cities from CSV...`);

                // Define bubble size scale
                const bubbleScale = d3.scaleSqrt()
                  .domain([1, d3.max(cityData, d => d.count) || 10])
                  .range([4, 15]); // Min and max radius

                // Add city bubbles
                const cities = mapGroup.selectAll(".city-bubble")
                  .data(cityData)
                  .enter()
                  .append("g")
                  .attr("class", "city-group");

                // Draw city bubbles
                cities.append("circle")
                  .attr("class", "city-bubble")
                  .attr("cx", d => {
                    const coords = projection([d.longitude, d.latitude]);
                    console.log(`City: ${d.city}, Longitude: ${d.longitude}, Latitude: ${d.latitude}, Projected coords:`, coords);
                    return coords ? coords[0] : 0;
                  })
                  .attr("cy", d => {
                    const coords = projection([d.longitude, d.latitude]);
                    return coords ? coords[1] : 0;
                  })
                  .attr("r", d => bubbleScale(d.count));

              } catch (err) {
                console.error("Error processing CSV data:", err);
              }
            })
            .catch(function(error) {
              console.error("Error loading CSV data:", error);
            });
        })
        .catch(function(error) {
          console.error("Error loading world data:", error);
        });
    }

    // Parse CSV data and convert to proper format
    function processCSVData(csvData) {
      console.log("First row of CSV data:", csvData[0]);

      // Create a deep copy of the data to avoid modifying the original
      const processedData = JSON.parse(JSON.stringify(csvData));

      // Clean the latitude and longitude values
      processedData.forEach(d => {
        try {
          // Handle missing values
          if (!d.latitude || !d.longitude || !d.city || !d.country) {
            console.warn("Row missing required data:", d);
            d.valid = false;
            return;
          }

          d.valid = true;
          // Extract numeric values from latitude and longitude strings
          if (typeof d.latitude === 'string') {
            if (d.latitude.includes('°')) {
              // Handle DMS format
              let lat = d.latitude.replace(/°\s*[NS]/, '');
              d.latitude = parseFloat(lat);

              // Adjust for hemisphere
              if (d.latitude.includes('S')) d.latitude = -d.latitude;
            } else {
              // Handle standard format
              d.latitude = parseFloat(d.latitude);
            }
          }

          if (typeof d.longitude === 'string') {
            if (d.longitude.includes('°')) {
              // Handle DMS format
              let lon = d.longitude.replace(/°\s*[EW]/, '');
              d.longitude = parseFloat(lon);

              // Adjust for hemisphere
              if (d.longitude.includes('W')) d.longitude = -d.longitude;
            } else {
              // Handle standard format
              d.longitude = parseFloat(d.longitude);
            }
          }

          // Validate the coordinates are within reasonable bounds
          if (d.latitude < -90 || d.latitude > 90 || d.longitude < -180 || d.longitude > 180) {
            console.warn("Coordinates out of range:", d);
            d.valid = false;
          }
        } catch (err) {
          console.error("Error processing coordinates for row:", d, err);
          d.valid = false;
        }
      });

      // Filter out any rows with invalid coordinates
      const validData = processedData.filter(d => {
        const valid = d.valid && !isNaN(d.latitude) && !isNaN(d.longitude);
        if (!valid) console.warn("Filtering out invalid row:", d);
        return valid;
      });

      console.log(`Filtered data: ${validData.length} valid entries out of ${processedData.length}`);

      if (validData.length === 0) {
        console.warn("No valid data entries found after filtering");
        return [];
      }

      // Group data by city to count frequencies
      const cityMap = new Map();

      validData.forEach(d => {
        const key = `${d.city}, ${d.country}`;
        if (!cityMap.has(key)) {
          cityMap.set(key, {
            city: d.city,
            country: d.country,
            latitude: d.latitude,
            longitude: d.longitude,
            count: 1
          });
        } else {
          cityMap.get(key).count += 1;
        }
      });

      const cityData = Array.from(cityMap.values());
      console.log("Final city data:", cityData);

      return cityData;
    }

    function generateDotPattern(width, height, world) {
      const ctx = document.createElement('canvas').getContext('2d');
      ctx.canvas.width = width;
      ctx.canvas.height = height;

      // Set up the projections
      const projection = d3.geoNaturalEarth1().fitSize([width, height], { type: "Sphere" });
      const path = d3.geoPath(projection, ctx);

      // Create a land shape | Filter out Antarctica
      const land = topojson.merge(world, world.objects.countries.geometries.filter(d => d.id !== "010"));

      // Make the fill canvas black
      ctx.fillRect(0, 0, width, height);

      // Initialize the context's path with the desired boundary
      ctx.beginPath();
      path(land);
      // Also fill it white
      ctx.fillStyle = "white";
      ctx.fill();

      // Iterate over the grid and test whether points are inside
      const size = 6; // Adjust the size of the grid
      let points = [];
      for (let y = size / 2; y <= height + size / 2; y += size) {
        for (let x = size / 2; x <= width + size / 2; x += size) {
          if (ctx.isPointInPath(x, y)) {
            // Get the average pixel value of the rectangle around the x, and y point
            let data = ctx.getImageData(x - size / 2, y - size / 2, size, size).data;
            // Since it is all black or white, I only need either the r, g, or b (not the a (alpha)) value of each pixel
            data = data.filter((_, i) => (i - 1) % 4 === 0);
            // Average it all out, so get "the average amount of white of the pixel"
            const avg = d3.mean(data);

            points.push({ x: x, y: y, avg: avg });
          }
        }
      }

      return points;
    }

    // Initial setup and draw
    window.addEventListener('resize', resizeMap);
    resizeMap();

  </script>
</body>
</html>
