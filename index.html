<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <title>Jam Music Lab</title>
</head>
<body>
  <div class="container">
    <h1>Mapping the Sound</h1>
    <p class="subtitle">
      Visualizing the Global Reach of Vienna's Jam Music Lab Faculty Through Concerts, Tours, and Collaborations
    </p>
    <div class="legend-container">
        <div class="legend-title">Number <br>of Concerts</div>
        <div class="legend-content">
            <div class="legend-row">
                <div class="legend">
                    <div class="legend-circle"></div>
                    <div class="legend-text">Larger bubbles indicate<br>more concerts</div>
                </div>
            </div>
            <div class="legend-row">
                <div class="heatmap-legend">
                    <div class="heatmap-label">Less</div>
                    <div class="heatmap-box"></div>
                    <div class="heatmap-box"></div>
                    <div class="heatmap-box"></div>
                    <div class="heatmap-box"></div>
                    <div class="heatmap-box"></div>
                    <div class="heatmap-label">More</div>
                </div>
            </div>
        </div>
    </div>
    <svg id="mapSvg"></svg>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
  <script>
    // Resize function to handle window resizing
    function resizeMap() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      // Clear previous content
      d3.select("#mapSvg").html("");

      // Set SVG dimensions
      d3.select("#mapSvg")
        .attr("width", width)
        .attr("height", height);

      drawMap(width, height);
    }

    // Initial setup and draw
    window.addEventListener('resize', resizeMap);
    resizeMap();

    function drawMap(width, height) {
      // Define margins
      const margin = {
        top: 200,
        right: 100,
        bottom: 50,
        left: 0
      };

      // Adjust dimensions to account for margins
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      // Get SVG element
      const svg = d3.select("#mapSvg");

      // Create a group for the map with margins applied
      const mapGroup = svg.append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

      // Load world map data
      d3.json("data/world.json")
        .then(function(world) {
          // Generate dot pattern points
          const points = generateDotPattern(innerWidth, innerHeight, world);

          // Draw the dots
          mapGroup.selectAll("circle")
            .data(points)
            .join("circle")
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("r", d => d.avg / 255 * 2) // Adjust the size based on the average value
            .attr("fill", "#636363");
        })
        .catch(function(error) {
          console.error("Error loading map data:", error);
          svg.append("text")
            .attr("x", width / 2)
            .attr("y", height / 2)
            .attr("text-anchor", "middle")
            .text("Error loading map data. Please check console for details.");
        });
    }

    function generateDotPattern(width, height, world) {
      const ctx = document.createElement('canvas').getContext('2d');
      ctx.canvas.width = width;
      ctx.canvas.height = height;

      // Set up the projections
      const projection = d3.geoNaturalEarth1().fitWidth(width, { type: "Sphere" });
      const path = d3.geoPath(projection, ctx);

      // Create a land shape | Filter out Antarctica
      const land = topojson.merge(world, world.objects.countries.geometries.filter(d => d.id !== "010"));

      // Make the fill canvas black
      ctx.fillRect(0, 0, width, height);

      // Initialize the contextâ€™s path with the desired boundary
      ctx.beginPath();
      path(land);
      // Also fill it white
      ctx.fillStyle = "white";
      ctx.fill();

      // Iterate over the grid and test whether points are inside
      const size = 6; // Adjust the size of the grid
      let points = [];
      for (let y = size / 2; y <= height + size / 2; y += size) {
        for (let x = size / 2; x <= width + size / 2; x += size) {
          if (ctx.isPointInPath(x, y)) {
            // Get the average pixel value of the rectangle around the x, and y point
            // using the Uint8ClampedArray that the getImageData().data returns
            let data = ctx.getImageData(x - size / 2, y - size / 2, size, size).data;
            // Since it is all black or white, I only need either the r, g, or b (not the a (alpha)) value of each pixel
            data = data.filter((_, i) => (i - 1) % 4 === 0);
            // Average it all out, so get "the average amount of white of the pixel"
            // The more white, the larger the eventual shape becomes
            const avg = d3.mean(data);

            points.push({ x: x, y: y, avg: avg });
          }
        }
      }

      return points;
    }
  </script>
</body>
</html>
